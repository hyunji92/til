# 2017.02.18 
## SICP 1.3.2 ~ 
## 정현지

---
# 1.3.2 Lambda로 나타내는 프로시저

---

### 먼저, Lambda Expression은 뭘까?
java의 lambda를 예로 생각해봐도 비슷하다.

`익명 클래스처럼 이름없는 함수면서 메서드를 인수로 전달할 수 있다.`

---
### Lambda
람다라는 용어는 람다 미적분학 학계에서 개발한 시스템? 에서 유래.

java, 그리고 이 책에서 배우는 Lisp에서도 lambda식을 하용하는 것은 코드와 값을 전달하는 과정에서 
필요이상의 코드가 많이 나올때 람다를 이용해서 간결한 방식으로 코드를 전달할 수 있음을 설명한다.

---
java 1.8 에서는 동작 파라미터 형식의 코드를 쉽게 구현하여 파라미터로 함수를 넘기며 간결해지는 코드를 볼 수 있다.

>example
```
process(() -> System.out.println("hello ! SICP "));
```


이처럼 람다 표현식은 파라미터, 화살표, 바디로 이루어진다.
`() ->` 파라미터가 없는것!

---

### 1.3.1절에서 sum을 만들 때 처럼, 인자로 건넬 경우에만 쓰려고 프로시저를 하나하나 만들기에는 귀찮은 일!

```
(define (sum-integere a b)
	(if (< a b)
    	0
        (+ a (sum-integers (+ a 1) b))))
    
    // a 부터 b 까지 정수의 합 계산 프로시저
```
---

### Lambda라는 Special form의 도움을 받아보자.

'인자에 4를 더해 돌려주는 프로시저'
```
(lambda (x) (+ x 4))
```
'인자와 인자에 2를 더한 값을 곱하여 역수를 나타내는 프로시저'
```
(lambda (x) (/ 1.0 (* x (+ x 2))))
```
--- 

### 이처럼 lambda를 쓰면 작은 프로시저를 따로만들지않아도 된다.
```
(define (pi-sum a b)
	(sum (lambda (x) (/ 1.0 (* x (+ x 2))))
    	 a
         (lambda (x) (+ x 4))
         b))
```
---

### *lambda는 define으로 프로시저를 정의내린 것과 크게 다르지않으나, 프로시저에 이름을 붙이지 않는다!*

```
(lambda (<formal-parameters>) <body>)
```
---

### lambda 식을 계산하여 얻어낸 프로시저 = define으로 정의한 프로시저

```
(define (plus4 X) (+ x 4))
```
   || 아래 lambda식에 define으로 붙인 프로시저와 같다.
```
(define plus4 (lambda (x) (+ x 4)))
```
---
### 프로시저이름이 들어갈 수 있는 모든자리에 lambda 식을 써도 좋은것!
```
(lambda -> the procedure
	
    (x) -> of an argument x
    
    ( +  x  4)) -> that adds x  and  4

```
---
### let 으로 Lacal Varialble (갇힌 변수) 만들기
- 프로시저안에서 인자로 받는 변수뿐만 아니라 프로시저 안에서만 쓸 변수를 만들어본다.
- 프로시저 안에 갇힌 변수를 만들어 쓰고 싶을 때  lambda를 쓸수도 있다.

---

*f*(x,y) = x(1+xy) + y(1-y) + (1+xy)(1-y)

```
a = 1 +xy
b = 1 - y
```
위의 식을 간추릴수 있다

*f*(x,y) = xa + yb + ab
---

---

# let
작은 프로시저를 하나 만들어서 그인자를 갇힌 변수 (a,b)처럼 쓰는 방법이다.
반복되는 식이 있는자리에 a,b와같은 정의해놓은 값이 들어가서 식을 간단하게 만든다.

---

```
(define (f x y)
	(lambda (a b)
      (+ (* x (square a)
         (* y b)
         (* a b)))
    (+ 1 (* x y))
    (- 1 y)))
```
lambda를 써서 프로시저에 인자를 건네주도록 한다.

그렇지만 자주나오는 표현이 많아서 더 편하게 쓰라고만든  `let`을 써본다. 

---

### 위에서 봤던 식의 f를 고쳐본다
```
(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
        
   (+ (* x (square a))
      (* y b)
      (* a b))))
```
let문법에서 나오는것음 이름과 짝 지어 놓은 리스트 이다.
`(let ((var1 exp1)) - > var1이 exp1의 값을 가질 때`

---
여기서 잠깐?!

let 식에서 정의한 변수를 쓸 수 있는 범위가 let식의 몸속이라는것을 알아차린다..
---

---
`x가 5일때`

```
(+ (let ((x 3)) // let식에따라 x는 3이다. ( 위에서 x는 5라고 말했지만,)
	 (+ x (* x 10))) // x=3 + ( 3* 10) = 33
     x) // 여기서는 위의 x값을 정한것에따라 let식의 밖이라서 x = 5
```
결과적으로 33 + 5 = 38 의 결과값이 나온다.

---

# 1.3.3 일반적인 방법을 표현하는 프로시저

---

### 차수 높은 프로시저를 만들어 쓰면, 간추려 만든 프로시저의 쓰임새를 늘릴 수 있다.
### 수뿐 아니라, 함수까지 인자로 받을 수 있기 때문에, 계산하는 방법만 도려내어 프로시저로 간추리는것이 가능하다.

---

## 이분법으로 방정식의 근찾기

이분법 ( half - interval method ) 어떤 너비를 반으로 나누는 방법.

---
`f(x) = 0 근 찾기`
f(a) < 0 < f(b) 인 두점 a , b가 있을때 a와 b사이에 *f*근이 적어도 하나있다는 사실을 바탕으로 두고
근을 찾는다.

`근이 어디있는지 알기위해`
a 와 b의 평균값 x로 *f*(x)값을 얻는다.
- *f*(x) > 0 이면 *f*의 근은 a와 x사이에 있고,
- *f*(x) < 0 이면 *f*의 근은 x와 b사이에 있다.



---

