# 1.3 차수 높은 프로시저로 요약하는 방법

차수 높은 프로시저를 얘기하기 전에 먼저,

연산에서 쓰이는 수가 어떤 수인지는 가리지 않고, 연산만 간추린 것이 있다.

```lisp
(define (cube x) (* x x x))
```

위의 프로시저는 정수인지 실수인지 가리지않고 수를 세제곱하는 식을 간추린것이다. ( 하지만  세제곱 연산이 필요할 때 이런 식을 쓰지않고 그냥 `(* y  y  y)`로 풀어서 쓸 수는 있다. )

하지만 이렇게 풀어 계산 하는 것보다,

-> 계산에서 되풀이되는 방법을 간추려서 이름을 붇이고 표현수단을 곧바로 만들어 쓰는 기능이 필요하다.

### 그런 기능중 하나가 바로 `프로시저` !! 

`차수 높은 프로시저 ` : 프로시저를 보통의 데이터 처럼 사용하는 프로시저로, 되풀이 되는 계산 방법을 간추리려면 프로시저를 인자로 받는다거나 결과 값으로 되돌려 주는 프로시저를 만들 수 있다.

```lisp
*차수 높은 프로시저 / 회차가 높은  
f(x)  -> g(f(x)) -> h(g(f(x)))
```

# 1.3.1 프로시저를 인자로 받는 프로시저 

> 먼저 예제로 살펴보자

1. a부터 b까지 정수의 합을 계산하는 프로시저

```lisp
(define (sum-integers a b)
  (if (> a b)
      0
   	  (+a (sum-integers (+ a 1))))
```

2. 정해진 넓이 속 정수를 모두 세제곱하여 더하는 프로시저

```lisp
(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a) (sum-cubes (+ a 1) b))))
```

3. 수열에서 모든 마디(항)를 더하는 프로시저

```lisp
(define (<name> a b)
  (if (> a b)
      0
      (+ (<term> a)
         (<name> (<next> a) b))))
```

####  => 위 세개의 프로시저를 보면 세 프로시저가 같은 계산 방법을 씀을 알 수 있다.

`프로시저의 이름`, `a를 받아서 계산하는 함수`, `a 다음 값을 얻어내는 함수` 만 다르고 나머지는 거의 같은 형식인것을 볼 수 있다.

#### => 앞서 나온 세 프로시저를 빈곳을 만들어 채우도록 만들어 낼 수 있다.

```lisp
(define (<name> a b)
  (if (> a b)
      0
      (+ (<term> a)
         (<name> (<next> a) b))))
```

이렇게 여러 프로시저에서 같은 계산방법을 쓰고있는 것을 볼 때, 간추린 프로시저(표현수단) 이 나올 수 있다. 

- 실제 수학자들은 *수열을 덧셈* 하는 계산방법인 '시그마 표현'도 만들어 냈다.

프로그램을 잘때도 덧셈한다는 개념이나 어떠한 개념을 바로 나타낼 만큼 충분한 표현을 나타낼 수 있다.

바로 위의 예제의 <빈곳>에 인자를 넣어 `틀이되는 프로시저`를 만들 수 있다.

```lisp
(define (sum term a next b)
  (if(> a b)
     0
     (+ (term a)
        (sum term (next a) b))))
```

-> sum이 수의 넓이를 나타내는 a, b 뿐아니라 프로시저 인자 term과 next를 받고있다.

-> sum을 쓰는 방법은 보통 프로시저와 같다.

-> 인자에 1을 더하는 프로시저 inc와 함께 sum-cubes를 다음처럼 정의 할 수 있다.

```Lisp
(define (inc n) (+ n 1))

(define (sum))
```

