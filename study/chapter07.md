Part || 비동기 기법
#기본 스레드의 생명주기 관리
> 스레드 사용의 몇가지 기본사항을 다루고, 안드로이드 구성요소와 협력하는 스레드에 대해 보고, 스레드 관리로 마무리!

###7.1 기본사항
> 안드로이드 Thread클래스는 일반 자바 프로그래밍에서의 Thread 클래스와 다르지 않다.
> 안드로이드의 Thread는 리눅스에서 응용프로그램이 가지게 되는 하부 리눅스 네이티브 스레드의 가장 가까운 표현체이다.

Thread는 Runable을 구현한다.그래서 실행되는 작업으 스래드 자체이거나 스레드가 생성하는 동안 주입되어 정의된다.

####7.1.1 생명주기 
` | 생성 |`
- 스레드 실행전에 Thread객체를 생성해야함
- 기본적으로 스레드 셍성시 new Thread는 생성되고있는 동일한 스레드 그룹에 동일한 우선순위로 할당된다.
즉, UI스레드로부터 생성된 스레드 UI스레드와 같은 우선순위의 스레드 그룹에 속한다.

` | 실행 |`
- Thread.start() 가 호출될때 실행환경 설정, 준비, Runable()상태
- 스케줄러가 실행을 위해 스레드를 선태가면 run 메서드 호출

` | 차단 , 대기 |`
1. Thread.sleep() : 스레드가 일정 시간 동안 자도록 만든 후 다시 실행하기 위해 (p41/ obiect.wait())
2. Thread.yield() : 스레드가 포기하고 스케줄러가 어떤 스레드를 실행할지 결정하게 한다.
(스케줄러는 자유롭게 실행할 스레드를 선택 , 스케줄러가 다른 스레드를 선택한다는 보장은 없다.)

--->>> 인터럽트가 되면 그때 Exception을 던진다. 차단 상태일때 스레드 실행을 던졌기 때문에 에러가 나온다.

` | 종료 |`
1. run메서드가 실행을 완료하면 스레드가 종료되고 스레드의 자원은 해제될 수 있다. - 최종상태
2. Thread인스턴스나 실행환경의 재상용의 불가능하다.

!!!스레드를 하나만드는데 너무 큰 시간이 걸려서 스레드는 재사용 불가

####7.1.2 인터럽트
> 응용프로그램은 태스크가 완료되기 전에 스레드의 실행을 종료하길 원할 수 있다.
> 대신 스레드가 종료하도록 스레드에 `인터럽트`를 요청할 수 있다.
> 인터럽트는 Boolean값이기 때문에 thread.interrupt();한다고 무조건 불리는것이아니다.

```java
while(isInterrupted() == false){
	// 체크하고 스레드를  처리할지?
}
```

- 인터럽트에 대한 실행 여부는 스레드 자체가 결정한다.
- 스레드 인터럽트는 공통으로 구현되고 즉, 스래드가 자신을 인터럽트 가능하게 하면 다른 스레드가 그 스레드에 인터럽트를 요청하는 식이다.
- 인터럽트된 스레드는 인터럽트를 감지하고 정사적으로 종료할 수 있도록 자신의 플래그를 확인해야한다.
- 스레드는 다른 스레드가 자신을 인터럽트하고 종료할 수 있도록 취소지점을 구현해야한다.

```java
public class SimpleThread extands Thread {
	@Override
    public void run(){
    	while(isInterrunpted() == false){
        	//스레드가 살아있다.
        }
        // 태스크가 완료되고 스레드가 종료된다.
        // 인터럽트 플래그를 확인하여 구현한다.
        // 현재 차단된 스레드가 인터럽트 되면 InterrupException을 던진다.
    }
}
```
`따라서`, 스레드가 인터럽트시 어떤 정리작업도 수행할 필요가 없다면 스레드는 더 위쪽 스택으로 Interrupexception을 전달해야 한다.

```java
void myMethod(){
	tru {
    	//차단호출
    } catch (InterruptedException e) {
    	//1. 정리작업
        //2. 다시한번 인터럽트
        Thread.currentThread().interrupt();
        //`이후 실행하는 메서드의 호출자가 인터럽트를 인식하도록 스레드는 자신을 다시 인터럽트 해야한다`
    }
}
```

*NOTE*
- Thread.interrupted()는 인터럽트 프래그값을 지우는 작업을 가져온다.
- Thread.stop()를 사용한지마 ; 공유객체를 일관적이지 못하고 예측 불가능하게 만든다.

####7.1.3 잡히지 않는 에러
>실행중인 java thread는 Runnable.run()메서드의 끝과 같이 코드 경로가 끝에 도달하거나 더 실행 코다가 없을때 정상적으로 종료한다.
>필수적으로 try/catch 절 안에 처리코드를 피요로하지않아서 스레드의 호출 스택을 따라 전파할 수 있따.
>스레드가 종료되기 전에 호출되는 UncaughExceptionHandler 를 부착할 수 있다.


- 스레드 전역 핸들러
```java
static void setDefaultUncaughtExceptionHandler(
	Thread.UncaughtExceptionHandler handler;
)
```

- 스레드 지역 핸들러
```java
void setUncaughtExceptionHandler(Thread.UncaughtExceptionhandler handler);
// 지역핸들러가 위의 전역보다 우선시되고 전역핸들러는 호출되지 않는다.
```

###7.2 스레드 관리
> 응용프로그램은 사용할 스레드의 수, 재사용 방법, 인터럽트 시기, 화면 회전 동안 스레드가 유지되어야 하는지 여부등을 결정해야한다.
스레드 특성
1. 스레드 생명주기 정의와 시작
2. 스레드 유지
3. 스레드 취소

세가지로 나눈 이유 - 스레드는 스레드마다 각자의 생명주기가 있다. 재사용되지않는경우에도 메모리에 유지할 수 있다.
공개스레드가 좋다고 생각하는데 - 외부 참조가 이루어지지않으면 메ㅣ모리가 누수가 적어질 수 잇고
인스턴스 생성은 메모리생성
클래스는 그렇지않아서 메모리 누수를 적게 말들수있다.


####7.2.1 정의와 시작
> 스레드는 여러 구성요소의 생명주기보다 오래 살 수 있고, 재새용되지 않는 경우에도 오래된 구성요소 객체를 메모리에 유지할 수 있다. 


#####익명 내부클래스
> 클래스 또는 메소드안에 또 다른 클래스를 만드는것
> 내부 클래스는 외부클래스의 모든 멤버를 자신의 멤버처럼 사용이 가능하다. (private 접근가능)
> static내부클래스를 제외하고 내부클래스는 항상 외부크래스의 객체를 통해서 생성할 수 잇따.

#####공개 스레드 
스레드는 스레드를 실행하는 클래스로 직접정의 하지 않고 독립형 클래스로 정의할 수 있다.

#####정적 내부 클래스 스레드 정의
>스레드를 내부 클래스로 정의 하는대신 정적 내부클래스로 정의할 수 잇다
>즉, 인스턴스 대신 클래스 객체안에서 정의가능!!!!!!! - 코드 필수 ㄴ마을미낭러미

정적 내부클래스는 인스턴스 클래스가 아니라  ( 외부 클래스의 클래스 객체에  ) == anyObject 만 참조를 유지한다.
따, 라, 서 인스턴스 객체의 의해 할당된 메모리는 스레드 참조로 인해 발생하는 누수가 일어날 수 없다.

###스레드 정의를 선택하는 방법 - 9장을 읽고 다시본다.
> 내부 클래스는 외부 참조를 포함하므로 많은 양의 메모리 누수가 될수 있다. 공개 클래스 및 정적 내부 클래스는 이러한 문제를 피할 수 있다.
>익명 내부 클래스는 스레드를 통제 불능으로 만드는 스레드 인스턴스에 대해 어떤 참조도 저장하지않는다. 저장된 스레드의 참조가 없으면 스레드는 응용 프로그램에 의해 영행을 받지 않는다.


응용프로그램은 리스트에 스레드 참조를 저장하거나 이전에 시작된 스레드가 더 살아있지 않은 경우에만 새로운 스레드를 시작하는 로직을 적용할 수 있다.
Thread가 동시 태스크의 수를 제한하게 하는 추가적인 로직이 필요할 수 있다.

####7.2.2유지
>스레드는 스레드나 스래드 하부의 객체를 시작하는 안드로이드 구성요소의 생명주기를 따르지 않는다. 일단 스레드가 시작되면 run 메서드가 끝나거나 전체 응용프로그램 프로세스가 종료될 때까지 실행된다. ----> 스레드 생명은 구성요소 수명보다 길어질 수 있다.

- 액티비티 구성요소의 설정이 변경되면서 : 스레드 결과를 받는 수신자가 없더라도 구성요소에서 사용되는 결과를 산출 할 수 있다. 
- 새로운 액티비티가 스레드의 결과를 활용할 데이터를 얻기 위해서 다시한번 스레드를 재시작 해야 한다.
- 설정 변경 동안 스레드를 유지하고 새로운 Activity객체가 이전 Activity 객체에 의해 시작된 스레드를 처리하도록 하는 것이다.

#####액티비티에서 스레드 유지

`public object onRetainNonConfigrationInstance()`
- 설정 변경은 현재 Activity객체가 파괴되고 다른 인스턴스로 대체 되도록 만든다. ( 설정 변경이 일어나기 전에 플랫폼에서 호출한다. )

`public Object getLastNonConfigrationInstance`
- 반환된 유지된 객체를 가져오기 위해 새로운 Activity 객체에서 호출한다.


코드 일부
```java
 extends AppCompatActivity {

    public static class MyThread extends Thread {
        private ThreadRetainActivity mActivity;

        public MyThread(ThreadRetainActivity activity) {
            mActivity = activity;
        }

        private void attach(ThreadRetainActivity activity) {
            mActivity = activity;
        }

        @Override
        public void run() {
            final String text = getTextFromNetwork();
            mActivity.setTitle(text);
        }

        private String getTextFromNetwork() {
            //네트워크 동작 시뮬레이션
            SystemClock.sleep(5000);
            return "text form network";
        }
    }

    private static MyThread t;
    private TextView textview;

    @Override
    public void onCreate(Bundle savedInstatnceState) {
        super.onCreate(savedInstatnceState);

    }
}

```

#####프래그먼트에서 스레드 유지
> 프래그먼트는 일반적으로 약티비티 안에서 사용자 인터페이스의 일부를 구현한다.
> 프래그먼트 사용시 인스턴스 유지가 더쉽고, thread인스턴스를 유지하는 책임을 약티비티에서 프래그먼트로 옮길 수 있다
> UI요소를 포함하지 않고 단지 스레드의 유지를 위해 액티비티에 추가될 수 있다.

- 프래그먼트에서 스레드나 다른 상태를 유지하는 방법은 => Fragment.onCreate() 에서 SetRetainInstance(true)를 호출하는것.
- 

java.lang.Thread객체는 안드로이드의 기본 스레드 실행 환경에서의 가장 기본적인 추상화를 표현한다.
시작된 모든 작업자 스레드는 네이티브 리눅스 스레드에 해당한다. 
인터럽트는 외부에서 스레드를 종료할 수 있는 유일한 명시적 방법이고, 응용프로그램은 메모리 누수의 위험과 크기를 줄이고, 
스레드의 시작과 종료를 제어하기 위해 스레드를 관리한다.

