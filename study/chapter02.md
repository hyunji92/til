#자바의 멀티스레딩
> 모든 안드로이드 응용프로그램은 자바언어의 멀티스레드 프로그래밍 모델을 따른다.

##2.1 스레드의 기본
> 명령어는 CPU가 순차적으로 츠리하는 응용프로그램 코드로 정의되는데, 이 응용프로그램 코드를 스레드의 고수준 정의라고 한다.
> 스레드에서 순차적으로 실행되는 코드경로, 즉 질서 정연하게 하나의 스레드에서 실행하는 작업의 단위를 테스크라고 한다.

####2.1.1 실행
>안드로이드 응용프로그램의 스레드는 java.lang.Thread에 의해 표현된다.
>스레드의 생존시간은 태스크의 길이에 의해 결정된다.

```java
private class MyTask implements Runnable {
	public void run() {
    	int i = 0; //  스레드의 지역 스택에 저장된다.
    }
}
```

- run()메서드 안에서 직간접적으로 호출되는 모든 지역변수는 스레드의 지역 메모리 스택에 저장된다.
- 운영체제 레벨에서의 스레드 명령어
	- 명령어 포인터  -  다음에 실행할 명령어
	- 스텍 포인터  -  스레드의 지역 데이터를 저장하는 전용 메모리 영역( 다른 스레드에서 접근 불가)

!!! 스레드의 지역 데이터  : 해당 응용프로그램의 자바 메서드에서 정의된 변수 리터럴
!!! CPU는 한 번에 하나의 스레드 명령어를 처리하 수 있다. CPU의 처리시간의 공유는 스케줄러에 의해처리된다.
	그러나 일반적으로 시스템은 동시에 실행되는 여러 응용프로그램처럼 동시에 처리를 해야 하는 멀티스레드를 보유한다.

> 스케줄링 전략은 다양한 방식으로 구현될 수 있지만 주로 스레드 우선순위를 기반으로 한다. 
> 기아 : 낮은 우선순위의 스레드는 의도된 작업을 수행할 충분한 처리 시간을 얻지못하는 경우 발생 이를 기아라고 한다,
> 문맥 교환 : 스레드의 변경을 문맥교환이라 한다.실행중인 스레드를 나중에 다시 시작할 수 있도록 상태를 저장하는 것으로 시작한다.
```
각 스케줄링 지점은 운영체제가 '스레드 전환을 수행' 하기 위해 CPU를 사용하는 문맥 교환을 포함한다.
```

####2.1.2 싱글스레드 응용프로그렘
> 싱글 스레드 환경에서 UI이벤트는 이전 명령어가 실행을 마치 때까지 지연 되므로 성능과 반응성이 저하될 수 있다. 이문제를 해결하려면 응용프로그램을 여러 개의 코드 경로로 실행해야 한다. 즉 스레드를 분리할 필요하가 있다.

####2.1.3 멀티 스레드 응용프로그램
> 실행하는 스레드 수가 프로세스의 수를 초과하면 완벽한 동시성이 도리 수없다. 그러나 스케줄러는 스레드 사이를 빠르게 전환하며, 순차적으로 처리되는 실행 간격 안으로 모든 코드 경로를 불리하여 처리한다.

- 자원 소비증가
스레드는 메모리와 프로세서 사용량 측면에서 오버헤드를 동반한다. 각 스레드는 메서드 실행 중에 지역변수 및 매개변수를 저장하는데 사용되는 전용 메모리 영역을 할당한다. 즉, 스레드가 활성화 되어 있거나 심지어 유후또는 차단된 경우에도 시스템 자원을 차지한다.
프로젝트 측면에서는 더많은 스레드가 실행될 수록 더 많은 문맥 교환이 일어나고 성능이 저하 될 수 있다.

- 데이터 불일치
자원접근의 순서가 불확정 적일 때 멀티스레드 프로그램에서는 새로운 문제가 발생한다.두개 이상의 스레드가 자원을 공유하는 경우 어떤 순서로 스레드가 자원에 도달하고 처리하는지 알수가 없는것이다.
`shared Resource`는 경쟁조건에 노출 된다. 경쟁조건은 실행할 때 마다 코드 순서가 다를 수 있기 때문에 발생 할 수 있는 상황이다. 그래서 항상다른 스레드의 간섭없이 순차적으로 실행되는 코드 명령어의 원자영역을 만드는것이 필요하다. 자바에서 원자영역은 하나의 스레드만 접근할 수 있기 때문에 상호배타적이라고 한다.
가장 기본적인 동기화 메커니즘은 `Synchronized` 이다. 공유 자원에 대한 모든 접근이 동기화 되면 멀티 스레드로 접근해도 모든 데이터의 일관성이 유지된다.

##2.2 스레드 안전
>여러 스레드에서 객체에 접근할 때 객체가 항상 정확한 상태를 유지해야! 스레드 안전이 보장된다. 동기화는 하나의 스레드에 의해 변경되는 도중에 다른 스레드의 접근이 가능한 모든 변수를 읽거나 쓰는 코드에 적용 되어야 한다. 이러한 코드 영역을 `임계역역`이라고 한다.

`임계영역 ` - 임계영역은 원자적으로 실행 되어야 하고, 한번에 하나의 스레드만 접근 허용되도록 실행되어야한다. 동기화는 현재 임계영역에서 실행되는 스레드가 있는지 확인하는 잠금 메커니즘으로 만들어진다.

####2.2.1암시적 잠금과 자바 모니터
> Synchronized 키워드는 모든 자바 객체에서 사용할 수 있는 암시적 잠금으로 동작한다. 암시적 잠금은 상호 배타적이고이는 `임계 영역`애서 스레드의 실행이 한 스레드에 적점적임을 의미한다.

```
하나의 스레드가 임계 영역을 점유하는 동안 다른 스레드의 접근은 차단되고 잠금이 해제될 때까지 실행을 할 수 없다.
```

####2.2.2 공유자원접근의 동기화
> 여러 스레드에서 접근하고 병경할 수 있는 `공유된 변경가능한 상태`는 동시실행중에 일관된 데이터를 유지하기 위해 동기화 전략이 필요하다.

- 암시작 잠금을 사용
암시적 잠근은 Synchronized키워드가 사용되는 방식에 따라 다른 방법으로 공유된 변경 가능한 상태를 보호할 수 있다.

- 명시적 잠금을 사용
더 향상된 고급 잠금 전략이 필요한 경우 Synchronized키워드 대신 ReentrantLock또는 ReentrantReadWriteLock 클래스를 사용한다. 임계 영역은 코드의 특정 부분에 대한 잠금 및 해제에 의해 보호받는다.

- Synchronized & ReentrantLock 
Synchronized 와 ReentrantLock 은 같은 의미를 가진다. 두 기법 모두 한스레드가 이미 임계영역에 들어온 경우 임계영역을 실행 하려는 모든 스레드를 차단한다. 이는 멀티스레드가 동시에 공유 변수를 읽는 것이 휴해하지 않다고 가정하는 방어적인 전략이다. 따라서 과잉보호로 이어질 수 있따.

####2.2.3 소비자와 생산자 (code check)
한 스레드는 데이터를 생산하고 한 스레드는 데이터를 소비하는 `소비자 생산자 패턴` 이 있다.공유되는 리스트를 통해 공동작업을 수행할 수 있다.공유 리스트를 보호하기 위해서 동일한 암시적 잠금을 사용한다. 

##2.3 태스크 실행 전략
> 멀티스레드가 반응성있는 응용프로그램을 만드는 데 적절히 사용되게 하려면 응용프로그램을 설계할 때 스레드 생성과 태스크 실행을 염두해 두어야 한다.

####2.3.1 동시 실행 설계
동시 실행은 다양한 방법으로 구현될 수 있으므로 설계시 실행하는 스레드의 개수와 그들의 관계를 관리하는 방법을 고려해야 한다.
- 자원의 생성과 해체의 
